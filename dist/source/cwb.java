/* autogenerated by Processing revision 1282 on 2022-09-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.video.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class cwb extends PApplet {



PImage src;
Movie srcv;
PImage out;

int wRadius = 15;
int wPickerP[] = new int[2];

int bRadius = 15;
int bPickerP[] = new int[2];

int previewFrame = 0;

boolean wCorrection = false;
boolean bCorrection = false;
boolean rendering = false;

int frameRendered = 0;
int frames = 0;
int renderStart = 0;


int threads = 16;
int finished = 0;

String sourceDir = "R:/src";
//String sourceDir = "D:/Projects/CWB Processing/cwb/src";
String outDir = "R:/out1";

java.io.File folder = new java.io.File(dataPath(sourceDir));
String filenames[] = folder.list();

 public void settings() {
  src = loadImage(sourceDir + "/" + filenames[0]);
  size(src.width, src.height, P2D);
  
  println("Sketch setting processed");
}

 public void setup() {
  println("Sketch setup started");

  out = createGraphics(width, height, P2D);
  
  //srcv = new Movie(this, "D:/Projects/CWB Processing/cwb/test.mov");
  //frameRate(25);
  //srcv.loop();
  
  frames = filenames.length;

  wPickerP[0] = width/2;
  wPickerP[1] = height/2;
  
  bPickerP[0] = width/2 + wRadius + bRadius + 10;
  bPickerP[1] = height/2;

  colorMode(RGB, 255, 255, 255);

  println("Sketch setup completed");
}

 public void draw() {
  if(!rendering){
    //if(!srcv.available()) return;
    //if(srcv.available()) srcv.read();
    //PImage f = srcv.get();
    //f.loadPixels();
    //println(f.pixels.length);
    
    //src = f;
    src.loadPixels();
    
    int srcWhite = sampleArea(src, wPickerP[0], wPickerP[1], wRadius);
    int srcBlack = sampleArea(src, bPickerP[0], bPickerP[1], bRadius);
    
    if(wCorrection || bCorrection){
      out = corrector(src, wCorrection, bCorrection);
    }
    
    image(wCorrection || bCorrection ? out : src, 0, 0);
  
    // White picker
    push();
      fill(0);
      text("White", wPickerP[0]-wRadius, wPickerP[1]-wRadius);
      fill(srcWhite);
      rect(wPickerP[0]-wRadius, wPickerP[1]-wRadius, wRadius*2, wRadius*2);
    pop();
    
    // Black picker
    if(bCorrection){
      push();
        fill(255);
        text("Black", bPickerP[0]-bRadius, bPickerP[1]-bRadius);
        fill(srcBlack);
        stroke(255);
        rect(bPickerP[0]-bRadius, bPickerP[1]-bRadius, bRadius*2, bRadius*2);
      pop();
    }
  
    push();
    noStroke();
    fill(0x55000000);
    rect(20, 20, 300, 100);
    pop();
  
    fill(255);
    text("Sample wRadius: " + nf(wRadius), 50, 50);
    text("Sample area center: [" + nf(wPickerP[0]) + ", " + nf(wPickerP[1]) + "]", 50, 65);
    text("Sampled color: " + hex(srcWhite).substring(2), 50, 80);
  
    push();
    fill(srcWhite);
    rect(190, 67, 20, 20);
    pop();
  
    //text("Sampled luma: " + nf(whiteLuma), 50, 95);
    text(wCorrection || bCorrection ? "CORRECTED IMAGE" : "SOURCE IMAGE", 50, 95);
    
    push();
      fill(0x55000000);
      rect(0,height-50, width, 50);
      fill(0xff000000);
      rect(width*previewFrame/frames, height-50, 20, 50);
    pop();
  }
  
  if(rendering){
    background(0);
    push();
      noStroke();
      fill(0xffFFFF00);
      rect(0,0,width*(float)frameRendered/(float)frames,height);
    pop();
    
    push();
      noStroke();
      fill(0x55000000);
      rect(20, 20, 300, 100);
    pop();
    
    text("RENDERING", 50, 60);
    text("Progress: " + nf(frameRendered) + "/" + nf(frames) + "frames (" + nf(((float)frameRendered/(float)frames)*100) + "% done)", 50, 75);
    
    text("Time elapsed: " + (millis()-renderStart)/1000 + "seconds", 50, 90);
    
    image(out, 20, 160, width/3, height/3);
  
  }
}

 public void startRender(){
  println("Starting render process");
  renderStart = millis();
  frameRendered = 0;
  frames = filenames.length;
  int t = threads < frames ? threads : frames;
  
  for(int i = 0; i<t; i++){
    new RenderThread(i*frames/t, (i+1)*frames/t).start();
    println("Starting thread " + i + " rendering frames " + i*frames/t + " thru " + (i+1)*frames/t);
  }
  
  noLoop();
  thread("onceASecond");
}

public class RenderThread extends Thread{
  int s;
  int e;
  public RenderThread(int start, int end){
    this.s = start;
    this.e = end;
  }
  
  public void run(){
    render(s,e);
  }
}

 public void render(int start, int end){
  rendering = true;
  
  for(int i = start; i<end; i++){
    if(!rendering) break;  // Stop the render if other thread have stopped
    if(keyPressed && keyCode == 9) {
      rendering = false;
      break; // If TAB was pressed, abort
    }
    
    frameRendered++;
    out = corrector(loadImage(sourceDir + "/" + filenames[i]), wCorrection, bCorrection);
    out.save(outDir + "/" + filenames[i]);
  }
  
  if(++finished == threads){
    rendering = false; // The last thread stops the render
    println("Finished render after " + (millis()-renderStart)/1000 + "seconds");
    loop();
  }
}

 public PImage corrector(PImage src, boolean wC, boolean bC){
  //colorMode(RGB, 255, 255, 255, 255);
  PImage o = createImage(src.width, src.height, ARGB);
  
  o.loadPixels();
  src.loadPixels();
  o.pixels = src.pixels.clone(); // Clone the pixel array into a new image which we can modify without worriing about destroing the source.
  
  int srcWhite = wC ? sampleArea(src, wPickerP[0], wPickerP[1], wRadius) : 0xffFFFFFF;
  int srcBlack = bC ? sampleArea(src, bPickerP[0], bPickerP[1], bRadius) : 0xff000000;
  
  //out.beginDraw();
  float wLuma = wC ? ((srcWhite>>16&0xFF) + (srcWhite>>8&0xFF) + (srcWhite&0xFF)) / 3f : 1;
  float bLuma = bC ? (red(srcBlack) + green(srcBlack) + blue(srcBlack)) / 3f : 0;
  float wFac[] = new float[3];
  float bFac[] = new float[3];
  for (int i = 0; i < 3; i++) {
    if(wC) wFac[i] = wLuma / ((srcWhite >> 8*(2-i))&0xFF) - 1;
    if(bC) bFac[i] = (255-bLuma) / (255-((srcBlack >> 8*(2-i))&0xFF)) - 1;
  }
  
  int count = o.pixels.length-1;
  for(int p = 0; p++ < count;){
    int c = o.pixels[p];
    int r = c >> 16 & 0xFF, g = c >> 8 & 0xFF, b = c >> 0 & 0xFF, a = c & 0xff000000; // Separate channels (and shift the color channels to LSB)
    
    float dr = r*wFac[0] -(255-r)*bFac[0];;
    float dg = g*wFac[1] -(255-g)*bFac[1];;
    float db = b*wFac[2] -(255-b)*bFac[2];;
    
    r = brick255(r + dr - (dg+db)/4) <<16 & 0x00FF0000; // Colorcombine the channels and shift the color back from LSB to b17 - b24
    g = brick255(g + dg - (dr+db)/4) <<8  & 0x0000FF00; // Colorcombine the channels and shift the color back from LSB to b9 - b16
    b = brick255(b + db - (dr+dg)/4)      & 0x000000FF; // Colorcombine the channels and shift the color back from LSB to b1 - b8
    
    o.pixels[p] = r+g+b+a;
    //println(hex(o.pixels[p]));
  }
  o.updatePixels();
  
  return o;
}

 public int brick255(float n){ // Brickwall color limiter to prevent 8bit overflows and simmilar shit
  return n > 255 ? 255 : (n < 0 ? 0 : floor(n));
}

 public void periodicUpdate(){
  while(mousePressed){
    src = loadImage(sourceDir + "/" + filenames[previewFrame]);
    delay(100);
  }
}

 public void onceASecond(){
  while(rendering){
    redraw();
    delay(1000);
  }
}

 public void mouseDragged(MouseEvent e) {
  if(rendering) return;
  
  if (abs(mouseX - wPickerP[0]) < (wRadius + 5) && abs(mouseY - wPickerP[1]) < (wRadius + 5) && wPickerP[1]-wRadius > 0) {
    wPickerP[0] += e.getX() - wPickerP[0];
    wPickerP[1] += e.getY() - wPickerP[1];
  }
  
  if (bCorrection && abs(mouseX - bPickerP[0]) < (bRadius + 5) && abs(mouseY - bPickerP[1]) < (bRadius + 5) && bPickerP[1]-bRadius > 0) {
    bPickerP[0] += e.getX() - bPickerP[0];
    bPickerP[1] += e.getY() - bPickerP[1];
  }
  
  if (abs(mouseX - width*previewFrame/frames) < 20 && mouseY > (height-50)) {
    previewFrame = mouseX*frames/width;
  }
}

 public void mouseReleased(){
   src = loadImage(sourceDir + "/" + filenames[previewFrame]);
}

 public void mouseWheel(MouseEvent e) {
  if(rendering) return;
  if(!keyPressed){
    if (wRadius >= 1) wRadius -= e.getCount();
    if (wRadius == 0) wRadius++;
  } else if(keyPressed && keyCode == SHIFT){
    if (bRadius >= 1) bRadius -= e.getCount();
    if (bRadius == 0) bRadius++;
  }
}

 public void mousePressed(MouseEvent e) {
  if(rendering) return;
  
  thread("periodicUpdate");
  
  if (!keyPressed && e.getButton() == RIGHT && mouseY < height-50) {
    wPickerP[0] = e.getX();
    wPickerP[1] = e.getY();
  } else if (keyPressed && keyCode == SHIFT && e.getButton() == RIGHT && mouseY < height-50) {
    bPickerP[0] = e.getX();
    bPickerP[1] = e.getY();
  }
  
  if (e.getButton() == RIGHT && mouseY > height-50) {
    previewFrame = mouseX*frames/width;
  }
}

 public void keyPressed(KeyEvent e) {
  if(key == 'w') wCorrect();    // w
  if(key == 'b') bCorrect();    // b
  if(key == ' ') correct();     // SPACE
  if(keyCode == 123) startRender();        // F12
}

 public void correct(){
  wCorrect();
  bCorrect();
}

 public void wCorrect(){
  wCorrection = !wCorrection;
}

 public void bCorrect(){
  bCorrection = !bCorrection;
}

 public int sampleArea(PImage sample, int x, int y, int r) { // Sample a part of an image and return the average color over that area
  //colorMode(ARGB,256,256,256,256);
  sample.loadPixels();    // Load the pixels into a buffer

  int rounds = (2*r)*(2*r);  // Determite the final number of pixels in the sampled area
  long sum[] = new long[3];  // Prepare an array into which we'll sum all the pixels
  
  int endX = x+r-1;
  int endY = y+r-1;
  for (int i = x-r; i++ < endX; ) for (int j = y-r; j++ < endY; ) {  // For every pixel in that area
    int p = j*sample.width + i;        // Calc the index of the current pixel
    sum[0] += (sample.pixels[p]>>16)&0xFF;  // Add the red channel //<>//
    sum[1] += (sample.pixels[p]>>8 )&0xFF;  // Add the green channel
    sum[2] += (sample.pixels[p]    )&0xFF;  // Add the blue channel
    //sample.pixels[p] = color(0xFFFF0000); // Test for showing the actual pixels sampled in red
  }
  //sample.updatePixels(); // Test for showing the actual pixels sampled in red

  for (int i = 0; i < 3; i++) sum[i] /= rounds; // Devide all the sums by the total amount of pixel = average
  //println((sum[0]<<8&0x0000FF00));

  return (int)0xff000000 + (int)(sum[0]<<16&0x00FF0000) + (int)(sum[1]<<8&0x0000FF00) + (int)(sum[2]&0x000000FF); // Composit the color back into a single int and return it.
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "cwb" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
